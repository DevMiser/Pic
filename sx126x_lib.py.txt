# sx126x_lib.py
# Modified from the original lora-code.py to remove debug prints.

import RPi.GPIO as GPIO
import serial
import time
import sys # Added for error reporting

class sx126x:
    M0 = 22
    M1 = 27

    # if the header is 0xC0, then the LoRa register settings dont lost when it poweroff, and
    # 0xC2 will be lost.
    cfg_reg = [0xC2,0x00,0x09,0x00,0x00,0x00,0x62,0x00,0x12,0x43,0x00,0x00]
    get_reg = bytes(12)
    rssi = False
    addr = 65535
    serial_n = ""
    addr_temp = 0
    freq = 915 # Default frequency
    start_freq = 850 # Default based on 915 Mhz
    offset_freq = 65 # Default based on 915 Mhz (915-850)

    # start frequence of two lora module
    # E22-400T22S E22-900T22S
    # 410~493MHz or 850~930MHz
    # start_freq = 850 # Set in __init__ based on freq

    # offset between start and end frequence of two lora module
    # E22-400T22S E22-900T22S
    # 410~493MHz or 850~930MHz
    # offset_freq = 18 # Set in __init__ based on freq

    SX126X_UART_BAUDRATE_1200 = 0x00
    SX126X_UART_BAUDRATE_2400 = 0x20
    SX126X_UART_BAUDRATE_4800 = 0x40
    SX126X_UART_BAUDRATE_9600 = 0x60
    SX126X_UART_BAUDRATE_19200 = 0x80
    SX126X_UART_BAUDRATE_38400 = 0xA0
    SX126X_UART_BAUDRATE_57600 = 0xC0
    SX126X_UART_BAUDRATE_115200 = 0xE0

    SX126X_PACKAGE_SIZE_240_BYTE = 0x00
    SX126X_PACKAGE_SIZE_128_BYTE = 0x40
    SX126X_PACKAGE_SIZE_64_BYTE = 0x80
    SX126X_PACKAGE_SIZE_32_BYTE = 0xC0

    SX126X_Power_22dBm = 0x00
    SX126X_Power_17dBm = 0x01
    SX126X_Power_13dBm = 0x02
    SX126X_Power_10dBm = 0x03

    lora_air_speed_dic = {
        1200:0x01,
        2400:0x02,
        4800:0x03,
        9600:0x04,
        19200:0x05,
        38400:0x06,
        62500:0x07
    }

    lora_power_dic = {
        22:0x00,
        17:0x01,
        13:0x02,
        10:0x03
    }

    lora_buffer_size_dic = {
        240:SX126X_PACKAGE_SIZE_240_BYTE,
        128:SX126X_PACKAGE_SIZE_128_BYTE,
        64:SX126X_PACKAGE_SIZE_64_BYTE,
        32:SX126X_PACKAGE_SIZE_32_BYTE
    }

    def __init__(self, serial_num, freq, addr, power, rssi, air_speed=2400,
                 net_id=0, buffer_size = 240, crypt=0,
                 relay=False, lbt=False, wor=False):
        self.rssi = rssi
        self.addr = addr
        self.freq = freq
        self.serial_n = serial_num
        self.power = power

        # Initial the GPIO for M0 and M1 Pin
        try:
            GPIO.setmode(GPIO.BCM)
            GPIO.setwarnings(False)
            GPIO.setup(self.M0,GPIO.OUT)
            GPIO.setup(self.M1,GPIO.OUT)
            GPIO.output(self.M0,GPIO.LOW)
            GPIO.output(self.M1,GPIO.HIGH) # Configuration mode
            time.sleep(0.1)
        except Exception as e:
             print(f"ERROR: GPIO setup failed: {e}")
             raise

        # The hardware UART of Pi3B+,Pi4B is /dev/ttyS0
        try:
            self.ser = serial.Serial(serial_num, 9600, timeout=0.5) # Added timeout
            self.ser.flushInput()
        except Exception as e:
            print(f"ERROR: Failed to open serial port {serial_num}: {e}")
            GPIO.cleanup() # Clean up GPIO if serial fails
            raise

        try:
            self.set(freq,addr,power,rssi,air_speed,net_id,buffer_size,crypt,relay,lbt,wor)
            # Switch to normal mode after configuration
            GPIO.output(self.M0,GPIO.LOW)
            GPIO.output(self.M1,GPIO.LOW)
            time.sleep(0.1)
        except Exception as e:
            print(f"ERROR: Failed during LoRa module set operation: {e}")
            self.ser.close()
            GPIO.cleanup()
            raise

    def set(self, freq, addr, power, rssi, air_speed=2400,
            net_id=0, buffer_size = 240, crypt=0,
            relay=False, lbt=False, wor=False):

        # Ensure M0=LOW, M1=HIGH for configuration
        GPIO.output(self.M0,GPIO.LOW)
        GPIO.output(self.M1,GPIO.HIGH)
        time.sleep(0.1)

        low_addr = addr & 0xff
        high_addr = addr >> 8 & 0xff
        net_id_temp = net_id & 0xff

        # Calculate frequency setting
        if freq >= 850 and freq <= 930:
             self.start_freq = 850
             self.offset_freq = freq - 850
        elif freq >= 410 and freq <= 493:
             self.start_freq = 410
             self.offset_freq = freq - 410
        else:
             print(f"ERROR: Frequency {freq} unsupported. Use 410-493MHz or 850-930MHz.")
             raise ValueError("Unsupported frequency")

        air_speed_temp = self.lora_air_speed_dic.get(air_speed)
        if air_speed_temp is None:
            print(f"ERROR: Invalid air speed {air_speed}")
            raise ValueError("Invalid air speed")

        buffer_size_temp = self.lora_buffer_size_dic.get(buffer_size)
        if buffer_size_temp is None:
            print(f"ERROR: Invalid buffer size {buffer_size}")
            raise ValueError("Invalid buffer size")

        power_temp = self.lora_power_dic.get(power)
        if power_temp is None:
            print(f"ERROR: Invalid power setting {power}")
            raise ValueError("Invalid power setting")

        rssi_temp = 0x80 if rssi else 0x00
        l_crypt = crypt & 0xff
        h_crypt = crypt >> 8 & 0xff

        # Simplified relay check
        if relay:
             print("Warning: Relay mode configuration not fully implemented in this simplified version.")
             # Basic relay mode settings (may need adjustment based on specific use case)
             self.cfg_reg[3] = 0x01 # Example high addr for relay
             self.cfg_reg[4] = 0x02 # Example low addr for relay
             self.cfg_reg[5] = net_id_temp # Keep network ID
             self.cfg_reg[9] = 0x03 + rssi_temp # Option byte for relay mode
        else:
             # Normal mode settings
             self.cfg_reg[3] = high_addr
             self.cfg_reg[4] = low_addr
             self.cfg_reg[5] = net_id_temp
             self.cfg_reg[9] = 0x43 + rssi_temp # Option byte for normal transparent transmission

        # Common settings
        self.cfg_reg[6] = self.SX126X_UART_BAUDRATE_9600 + air_speed_temp
        self.cfg_reg[7] = buffer_size_temp + power_temp + 0x20 # WOR cycle 2000ms (default)
        self.cfg_reg[8] = self.offset_freq
        self.cfg_reg[10] = h_crypt
        self.cfg_reg[11] = l_crypt

        # Send configuration command
        self.ser.flushInput()
        config_success = False
        for _ in range(3): # Try up to 3 times
            try:
                self.ser.write(bytes(self.cfg_reg))
                time.sleep(0.2) # Wait for response
                if self.ser.inWaiting() > 0:
                    r_buff = self.ser.read(self.ser.inWaiting())
                    if r_buff[0] == 0xC1: # Check for correct ACK
                        config_success = True
                        break # Success
                    else:
                        print(f"ERROR: Config attempt failed. Response: {r_buff.hex()}")
                else:
                    print("ERROR: Config attempt failed. No response from module.")
                time.sleep(0.5) # Wait before retrying
            except serial.SerialException as e:
                print(f"ERROR: Serial communication error during config: {e}")
                time.sleep(0.5) # Wait before retrying
            except Exception as e:
                print(f"ERROR: Unexpected error during config: {e}")
                time.sleep(0.5) # Wait before retrying

        if not config_success:
             print("FATAL: Module configuration failed after multiple attempts.")
             raise RuntimeError("Module configuration failed")

        # Do NOT switch back to normal mode here; __init__ will do it after calling set()

    def send(self, target_address, data):
        # Ensure M0=LOW, M1=LOW for transmission
        GPIO.output(self.M0,GPIO.LOW)
        GPIO.output(self.M1,GPIO.LOW)
        time.sleep(0.1)

        # Construct packet: Target Address High, Target Address Low, Target Freq Offset, Data
        low_addr = target_address & 0xff
        high_addr = target_address >> 8 & 0xff

        # Assuming target frequency is same as own frequency for simplicity
        # If different frequencies are needed, this needs adjustment
        target_offset_freq = self.offset_freq

        # Format: AddH, AddL, FreqOffset, Payload
        # The module automatically adds its own address and freq info in transparent mode
        # However, the example script main-script.py prepends sender info too.
        # Let's simplify and just send the payload in transparent mode.
        # The receiver example in main-script.py expects sender info,
        # so we'll prepend it for compatibility IF NEEDED, but ideally
        # just send the data bytes in transparent mode.
        # For this specific P2P case, we only need the data.
        # If the original format is strictly required:
        # packet = bytes([high_addr, low_addr, target_offset_freq,
        #                 self.addr >> 8, self.addr & 0xff, self.offset_freq]) + data
        # Sending only data for simplicity:
        packet = data

        try:
            self.ser.write(packet)
        except serial.SerialException as e:
            print(f"ERROR: Serial communication error during send: {e}")
        except Exception as e:
            print(f"ERROR: Unexpected error during send: {e}")

        # A short delay might be needed depending on data length and air speed
        # time.sleep(0.1 + len(data) / (self.lora_air_speed_dic.get(self.air_speed, 2400)/8)) # Estimate based on air speed

    def receive(self):
        # Ensure M0=LOW, M1=LOW for reception
        GPIO.output(self.M0,GPIO.LOW)
        GPIO.output(self.M1,GPIO.LOW)
        # No need to sleep here, just check buffer

        if self.ser.inWaiting() > 0:
            time.sleep(0.1) # Allow buffer to fill slightly
            try:
                r_buff = self.ser.read(self.ser.inWaiting())

                if self.rssi and len(r_buff) > 0:
                    # In RSSI mode, the last byte is the RSSI value
                    payload = r_buff[:-1]
                    rssi_val = 256 - r_buff[-1:][0]
                    # print(f"Packet RSSI: -{rssi_val}dBm") # Optional: re-enable if needed
                    return payload, rssi_val
                else:
                    # No RSSI byte expected
                    return r_buff, None # Return payload and None for RSSI
            except serial.SerialException as e:
                 print(f"ERROR: Serial communication error during receive: {e}")
                 return None, None
            except Exception as e:
                 print(f"ERROR: Unexpected error during receive: {e}")
                 return None, None
        else:
            return None, None # No data received

    def close(self):
        # Clean up GPIO and close serial port
        try:
            if self.ser and self.ser.isOpen():
                self.ser.close()
            GPIO.cleanup()
        except Exception as e:
            print(f"ERROR: Exception during cleanup: {e}")

# Example usage (for testing the library itself)
if __name__ == '__main__':
    print("Testing sx126x_lib.py")
    try:
        # Configure parameters (adjust as needed)
        SERIAL_PORT = "/dev/ttyS0"
        LORA_FREQ = 915
        LORA_ADDR = 0 # Example address
        LORA_POWER = 22
        LORA_RSSI = True
        LORA_AIR_SPEED = 2400

        node = sx126x(SERIAL_PORT, LORA_FREQ, LORA_ADDR, LORA_POWER, LORA_RSSI, LORA_AIR_SPEED)
        print("LoRa module initialized successfully.")

        # Example: Send a test message to address 1
        print("Sending test message 'Hello' to address 1")
        node.send(target_address=1, data=b'Hello')
        time.sleep(2)

        # Example: Try to receive for 5 seconds
        print("Listening for messages for 5 seconds...")
        start_time = time.time()
        while time.time() - start_time < 5:
            payload, rssi_val = node.receive()
            if payload:
                print(f"Received: {payload.decode(errors='ignore')}", end='')
                if rssi_val is not None:
                    print(f" (RSSI: -{rssi_val}dBm)")
                else:
                    print()
            time.sleep(0.1)

        print("Test finished.")

    except Exception as e:
        print(f"An error occurred: {e}")
    finally:
        if 'node' in locals() and node:
            node.close()
        print("Cleaned up.")